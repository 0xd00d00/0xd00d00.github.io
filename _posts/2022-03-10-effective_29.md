---
layout: post
author: doodoo
title: "[Effective C++] 항목 28: 내부에서 사용하는 객체에 대한 '핸들'을 반환하는
코드는 되도록 피하자"
subtitle: "캡슐화를 깰 수 있는 부분을 제거해보자! 👀"
date: 2022-03-10
cover: /assets/img/default.png
tags: Effective_C++ C++
sitemap :
 changefreq : daily
 priority : 1.0
---
안녕하세요! <span class="doodoo">두두코딩</span> 입니다 ✋ <br>
오늘은 Effective C++ 항목 28장에 대해 알아보겠습니다.

🖇 소스코드에 마우스를 올리고 <span class="tip">copy</span> 버튼을 누를 경우 더 쉽게 복사할 수 있습니다! 

궁금한 점, 보안점 남겨주시면 성실히 답변하겠습니다. 😁 <br>
\+ 감상평 댓글로 남겨주시면 힘이됩니다. 🙇

### 내부 '핸들' 반환 문제점
사각형을 사용하는 응용 프로그램을 만들고 있다고 가정해보자. 사각형같은 경우 좌측
상단 2개의 꼭지점과 우측 하단 꼭지점 2개로 나눌 수 있으며, 코드로 구현하면
다음과 같다.

```cpp
class Point {
public:
	Point (int x, int y);
	...
	void setX(int newVal);
	void sety(int newVal);
};

// 메모리 최적화를 위해 Point 관리 객체로 분리
struct RectData {
	Point ulhc;
	Point lrhc;
};

class Rectangle {
	...

private:
	std::tr1::shared_ptr<RectData> pData;
};
```

응용프로그램에서는 영역정보를 사용하기 때문에 좌측 상단 꼭지점을 반환 받는
`upperLeft` 함수와 우즉 하단 정보를 반환받는 `lowerRight` 함수를 멤버 변수로
들고 있을 것이다. 해당 함수 같은 경우 [항목20](http://localhost:4000/2021/09/26/effective_26.html)에서 배운 내용과 같이, 사용자 타입일 경우 참조로 반환하는 것이 좋아 아래와 같이 구현했다.

```cpp
class Rectangle {
public:
	...
	Point& upperLeft() const { return pData->ulhc; }
	Point& lowerRight() const { return pData->lrhc; }
};
```

위 함수 같은 경우 컴파일은 잘된다. `const` 키워드를 활용해 멤버 변수 내에서 값을
변경하지 못하도록 한다. 즉, 내부 데이터를 변경하지 못하도록 했기 때문에 아무
문제 없어보인다. 하지만, 생각해보면 해당 함수 같은 경우 *참조자*로 값을 반환하기
때문에 외부에서 수정이 가능하다. 

