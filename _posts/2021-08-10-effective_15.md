---
layout: post
author: doodoo
title: '[Effective C++] 항목 10: 대입 연산자는 *this의 참조자를 반환하게 하자'
subtitle: 2장. 생성자, 소멸자 및 대입연산자 🎺
date: 2021-08-10
cover: /assets/img/default.png
tags: Effective_C++ C++
sitemap :
 changefreq : daily
 priority : 1.0
---
안녕하세요! <span class="doodoo">두두코딩</span> 입니다 ✋ <br>
오늘은 항목 10 \*this 참조자 반환 개념에 대해 알아보겠습니다.

🖇 소스코드에 마우스를 올리고 <span class="tip">copy</span> 버튼을 누를 경우 더 쉽게 복사할 수 있습니다! 

궁금한 점, 보안점 남겨주시면 성실히 답변하겠습니다. 😁 <br>
\+ 감상평 댓글로 남겨주시면 힘이됩니다. 🙇

### 대입연산자의 특징
C++의 대입연산자는 여러개가 사슬처럼 묶일 수 있는 특징을 갖고있다.

```cpp
int x, y, z;

// 대입이 사슬처럼 이어짐.
x = y = z = 15;
```

대입연산의 또 다른 특징은 바로 *우측 연관 연산*이라는 점이다. 즉, 위의 대입 연산 사슬은 다음과 같이 풀어서 해석된다.

```cpp
x = ( y = ( z = 15 ) );
```

위의 코드를 해석해보면, 15가 `z`에 대입된다. 이후 갱신된 `z` 의 값이 `y`에 대입이 되고, 갱신된 `y`의 값이 `x`에 대입되는 형식을 띄고있다.

이렇게 대입 연산이 사슬처럼 엮이려면 대입 연산자가 좌변 인자에 대한 *참조자를 반환*하는 형식으로 구현되어져 있을 것이다.

### 대입연산자는 \*참조자를 반환
위와 같이, 대입연산이 사슬처럼 묶여서 사용되기 위해서는 좌변인자는 *참조자를 반환*하도록 되어져야한다. 이런 구현은 일종의 *관례 (convention)*으로 사용된다. 사용자가 만드는 클래스에 대입 연산자가 혹시 들어갈 경우 아래와 같이 구현하는 것이 좋다.

```cpp
class Widget {
public:
  ...
  // 반환 타입은 현재 클래스에 대한 참조자이다.
  Widget& operator=(const Widget& rhs)
  {
    ...
    return *this;
  }
  ...
};
```

"좌변 객체의 참조라를 반환하게 만들자"라는 관례는 위에서 본 단순 대입형 연산자 말고, 모든 형태의 대입 연산자에서 지켜져야한다. 예를 들면, `+=`, `-=`, `*=`등에도 적용이 되어져야한다는 점을 잊지말자.

```cpp
class Widget {
public:
  ...
  Widget& operator+=(const Widget& rhs)
  {
    ...
    return *this;
  }

  // 대입연산자의 매개변수 타입이
  // 일반적이지 않은 경우에도
  // 동일한 관례가 적용된다.
  Widget& operator=(int rhs)
  {
    ...
    return *this;
  }
};
```

<span class="tip">관례</span>란 따르지 않고 코드를 작성하더라도, 컴파일이 안된다거나 하는 것은 아니다. 하지만 해당 관례는 모든 기본제공 타입들이 따르고 있을 뿐아니라 STL에 속한 모든 타입 (string, vector, complex, tr1::shared_ptr 등)들이 따르고 있다. 특별한 일이 없다면, 관례에 따라 작성하는게 심신 안정이 좋을 것이라 생각한다 😙

### To Sum Up
👉 대입 연산자는 \*this의 참조자를 반환하도록 만들자.
