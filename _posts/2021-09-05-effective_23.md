---
layout: post
author: doodoo
title: "[Effective C++] 항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로
쓰기엔 어렵게 하자"
subtitle: "설계 및 선언 🔐"
date: 2021-09-05
cover: /assets/img/default.png
tags: Effective_C++ C++
sitemap :
 changefreq : daily
 priority : 1.0
---
안녕하세요! <span class="doodoo">두두코딩</span> 입니다 ✋ <br>
오늘은 인터페이스 설계에 대해 알아보겠습니다.

🖇 소스코드에 마우스를 올리고 <span class="tip">copy</span> 버튼을 누를 경우 더 쉽게 복사할 수 있습니다!

궁금한 점, 보안점 남겨주시면 성실히 답변하겠습니다. 😁 <br>
\+ 감상평 댓글로 남겨주시면 힘이됩니다. 🙇

### 들어가기 전에
소프트웨어 설계란 소프트웨어가 사용자가 원하는 동작을 하도록 틀을 짜는 방법을
말한다. 많은 개발자들은 "어떻게 하면 좋은 C++ 인터페이스를 설계하고 선언할 수 있을까?" 를 고민한다. 이번 장에서는 C++에서 어떤 인터페이스를 설계하든지 막론하고 중요한 지침들에 대해 알아본다. 가장 중요한 지침은 *제대로 쓰기엔 쉽게 엉터리로 쓰기엔 어렵게* 라는 지침이다.

*제대로 쓰기엔 쉽게 엉터리로 쓰기엔 어렵게* 라는 포문을 열고, 이 지침을 기반으로
정확성, 효율성, 효율, 캡슐화, 유지보수성 및 확장성 그리고 준수규약에 이르는
인터페이스의 설계에 얽힌 많은 문제에 대해 알아보자.

### 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게
C++에서는 함수, 클래스, 템플릿 등과 같이 인터페이스가 아주 많은 영역에서
사용된다. 보통 사용자들은 우리가 만든 인터페이스를 통해 우리의 소프트웨어를
사용한다. 의도를 갖지 않는 이상 사용자는 인터페이스에 의존해 작업을 수행할
것이다. 만약 잘못 사용할 경우, 우리는 인터페이스가 최소한 항의의 몸부림이라도
보여주어야 하는 *의무*를 갖고 있다.

*제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵운* 인터페이스를 개발하기 위해, 우리는
사용자가 저지를 만한 실수를 생각하고, 선조치를 취해야한다.

일례로, 날짜를 나타내는 어떤 클래스에 넣을 생성자를 설계하고 있다고 가정해보자.

```cpp
class Date {
public:
	Date(int month, int day, int year);
	...
};
```

우리가 흔히 사용하는 기법이다. `Date`라는 클래스를 만들고, 생성자의 인자로 월,
	일, 년도를 입력받는다. 해당 클래스 같은 경우 별 문제 없이 보이지만, 인터페이스
	관점에서 보게되면 *2 가지* 문제가 있다.

```cpp
// 1 번 문제
Data d (30, 3, 1995);
```

위와 같이, 첫 번째 문제는 *일과 월을 바꿔서 입력할 경우*이다. 즉, 3월 30일이어야 하는데 30월 3일로
잘못 전달할 경우 문제가 된다.

```cpp
// 2번 문제
Date d (3, 40, 1995);
```

두 번째 문제는 *월과 일에 해당하는 숫자를 잘못 입력할 경우*이다. 즉, 3월 30일을
입력하려고 있는데, "키보상 3 옆에 있는 4를 눌러" 3월 40일을 입력할 경우이다.

위의 문제를 해결하기 위해서는 *새로운 타입을 정의하는 것*을 활용해 사용자 실수를
막을 수 있다.

### 인터페이스 문제를 해결 하기 위한 새로운 타입 정의
위와 같은 케이스는 사용자가 잘못 입력헀지만, `int`라는 타입에는 명확하게 숫자가
전달돼 문제 없이 컴파일 된다. 이를 막기 위해시는 *타입 시스템*을 활용하면 된다.

일, 월 연을 구분하는 간단한 wrapper 타입을 만들고, 이 타입을 `Date` 생성자 안에
두면 문제를 해결 수 있다.

```cpp
struct Day {
	explicit Day(int d) : val(d) {}

	int val;
};

struct Month {
	explicit Month(int d) : val(d) {}

	int val;
};

struct Year {
	explicit Year(int d) : val(d) {}

	int val;
};

class Date {
public:
	Date(const Month& m, const Day& d, const Year& y);
	...
};

Date (Month(3), Day(40), Year(2021));  // 타입이 옳지 않아요
Date (Month(30), Day(3), Year(2021));  // 타입 확인해주세요!
Date (Month(3), Day(30), Year(2021));  // 정상입니다.
```

위와 같이 wrapper 함수를 만들어, 적절한 예외 처리를 넣어준다면 타입의 예외
처리로 문제를 해결할 수 있다.
